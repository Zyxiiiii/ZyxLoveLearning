[TOC]

# c++的第一个程序

```c++
#include <iostream>
using namespace std;

int main() 
{
	cout << "hello world" << endl;

	system("pause");
	return 0;
}
```

# 变量

## 创建变量的语法

* 数据类型 变量名 = 变量初始化值；	例：`int a = 0;`

```c++
#include <iostream>
using namespace std;

int main()
{
	int a = 10;
	cout << "a = " << a << endl;

	return 0;
}
```

# 常量

## 宏常量

* #define 常量名 常量值;	例：`#define DAY 7`

## `const`修饰的变量

* `const` 变量类型 变量名 = 变量值；	例：`const int MONTH = 12;`

```c++
#include <iostream>
using namespace std;

// 定义一个宏常量
#define DAY 7

int main()
{
	// 定义一个const修饰的变量
	const int MONTH = 12;
	cout << "一周有：" << DAY << "天" << endl;
	cout << "一年有：" << MONTH << "月" << endl;
	return 0;
}
```

# 标识符

* 标识符不得与关键字相同
* 标识符只能由字母、下划线"`_`"、数字组成
* 第一个字符必须是字母或下划线
* 区分大小写

<font style="color:gray">Tips：在取名时，要尽量做到见名知意，避免`a = 123;`这种让人不能一下子知道它是什么的变量名</font>

# 数据类型

## sizeof关键字

* 作用：统计变量/变量类型所占的内存空间的大小
* 语法：`sizeof(变量名/变量类型)`

<font style="color:gray">Tips具体例子在具体使用时会体现</font>

## 整型

| 数据类型  |                          占用空间                          |
| :-------: | :--------------------------------------------------------: |
|   short   |                           2 byte                           |
|    int    |                           4 byte                           |
|   long    | windows下为4 byte，Linux中为4 byte（32位）或8 byte（64位） |
| long long |                           8 byte                           |

* 以下为测试c++中各整型的长度（利用`sizeof`关键字）

```c++
#include <iostream>
using namespace std;

int main()
{
	// 短整型
	short a = 0;
	// 整型
	int b = 0;
	// 长整型
	long c = 0;
	// 长长整型
	long d = 0;

	cout << "short 类型的长度为：" << sizeof(a) << endl;
	cout << "int 类型的长度为：" << sizeof(b) << endl;
	cout << "long 类型的长度为：" << sizeof(c) << endl;
	cout << "long long 类型的长度为：" << sizeof(d) << endl;

	return 0;
}
```



![整型的数据长度](整型的数据长度.png)

## 浮点型（实型）

* 浮点型可以用于表示小数

| 数据类型 | 占用空间 | 有效数字范围 |
| :------: | :------: | :----------: |
|  float   |  4 byte  |     7位      |
|  double  |  8 byte  |   15~16位    |

* 以下为c++中各浮点型的使用以及所占内存空间的测试

``` c++
#include <iostream>
using namespace std;

int main()
{
	// 单精度浮点型
	float a = 123.12;
	// 双精度浮点型
	double b = 12.234;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "float 所占的内存空间大小为：" << sizeof(float) << endl;
	cout << "double 所占的内存空间大小为：" << sizeof(double) << endl;

	return 0;
}
```

![浮点型的使用和所占的内存空间大小](浮点型的使用和所占的内存空间大小.png)

-----

后面部分跳过

-----

# 指针

- 指针是一个存放了地址的变量，我们可以通过指针间接访问内存

- 定义一个指针

  `数据类型 * 变量名 = &另一个变量a`（`&`为取址符号，用于获取变量`a`的地址）

- 解引用

  解引用的意思是解开指针对地址的引用，这里解开指取得该地址的值，格式如下

  `*变量名 = 值`

  例：

    ```c++
    // 定义一个指针并将a的地址赋值给它
    int a = 1243;
    int * p = &a;
    // 对指针进行解引用
    *p = 1234;
    cout << "*p = " << *p << endl
    ```

- 指针对内存的占用

  - 32位操作系统下，指针占用4个字节
  - 64位操作系统下，指针占用8个字节

### 空指针、野指针

- 空指针：指向内存中内存编号为0的空间的指针

  作用：初始化指针变量

  Tips：编号`0~255`的指针都是不允许访问的

- 野指针：指向内存中非法内存空间的指针

  一般来说，我们新建或者说定义一个变量的过程，就是向系统申请内存空间的过程，未经系统允许，我们是不允许随意操作系统中的内存的。所以如果我们将一个指针指向了一个未经允许的地址，那么这个指针就会被判定为野指针，并且系统会报错，不允许我们对该地址进行操作

## 常量和指针

`const`修饰指针的三种情况

- `const`修饰指针：常量指针

  **指针的指向可变，指向的值不可变**

  `const 数据类型 * 变量名 = &a;`

- `const`修饰常量：指针常量

  **指针的指向不可边，指向的值可变**

  `数据类型 * const 变量名 = &a;`

- `const`既修饰指针，又修饰常量

  **指针的指向和值都不可变**

  `const 数据类型 * const 变量名 = &a;`

## 指针和数组

- 数组：数组是一段连续的空间中存放的相同类型的数据元素

  数组名代表的就是数组的第一个元素的地址

  - 因此，我们只需要先将指针指向数组首地址：`int * p = arr;`

  - 然后每一次读取完元素以后让指针往后偏移**一个单位长度（如int类型往后偏移4个字节）**：`p ++;`

  - 然后再进行读取：`*p;`

    *那么依照以上步骤进行下去，指针就能把整个数组遍历完*

## 指针和函数

- 传值

  ```c++
  void swap(int a, int b)
  {
      a = a + b;
      b = a - b;
      a = a - b;
      cout << a << b << endl;
  }
  ```

  以上`swap`函数只是将传入的形参做了一个拷贝，交换的并不是真正的变量，而是原变量的**副本**，**这种传递方式为传值**

- 传引用

  ```c++
  void swap(int * a, int * b)
  {
      *a = *a + *b;
      *b = *a - *b;
      *a = *a - *b;
      std::cout << *a << *b << std::endl;
  }
  ```

  而以上`swap`函数则是将地址作为参数传进了函数体，操作的是我们真正想要交换的变量，**这种传递方式则为传引用**

# 结构体

结构体属于**用户自定义的数据类型**，允许用户存储不同的数据类型

## 结构体的定义和使用

- 结构体的定义

  `struct 结构体名{结构体成员};`

- 通过结构体创建变量的方式

  - `struct 结构体名 变量名;` 

  - `struct 结构体名 变量名 = {成员1, 成员2......};`

  - 在定义结构体的时候，就将变量创建好，后续可以直接调用

    ```c++
    // 定义结构体
    struct Student
    {
        // 成员列表
        string name;
        int age;
        float score;
    }stu3; // 创建结构体变量的第3种方式
    
    // 创建结构体变量的第1种方式
    struct stu1;
    // 创建结构体变量的第2种方式
    struct stu2 = {"abc", 12, 99};
    ```

    Tips：在结构体变量**创建**时，

- 访问结构体成员：`结构体名.成员名`

## 结构体数组

- 作用：将自定义的结构体存放到数组种方便维护

- 语法：

  - 创建结构体数组：`struct 结构体名 数组名[元素个数] = { { }, { }, ..., { } };`
  - 访问结构体数组：`数组名[索引].成员名`（可以对结构体数组的某一元素的成员进行赋值或调用）

  例：

  ```c++
  // 定义一个结构体
  struct Student
  {
      string name;
      int age;
      float score;
  };
  
  // 创建结构体数组
  struct Student students[3] = 
  {
      {"zhangsan", 18, 60},
      {"lisi", 19, 65},
      {"wangwu", 18, 90} 
  };
  
  // 访问结构体数组中的元素
  std::cout << students[2].name << std::endl; // "wangwu"
  ```

## 结构体指针

- 结构体指针的定义：`struct 结构体名 * 指针名 = 变量取址;`

- 结构体指针访问结构体成员：`指针名 -> 成员名`

  例：

  ```c++
  // 结构体指针的定义
  struct Student * p = &student; // student{ name = "wangwu", age = 18, score = 90 }
  
  // 访问成员
  std::cout << "姓名: " << p -> name << std::endl; // "姓名: wangwu"
  ```

  

## 结构体嵌套

- 结构体嵌套：定义一个结构体时，将另一个结构体作为该结构体的成员

  例：

  ```c++
  struct student { };
  struct teacher
  {
      // 嵌套的学生结构体
      struct student stu;
  };
  ```

## 结构体作为函数参数

- 将结构体作为参数向函数中传递

- 结构体作为函数参数传递有两种方式

  - 值传递

    直接将变量作为参数传入函数

    函数的定义：`void func1(struct student s) { }`

  - 址传递

    将变量的地址作为参数传入函数，利用一个指针来接收这个地址

    函数的定义：`void func2(struct student * s) { }`

## const的使用场景

  - 防止在结构体中的误操作

# 引用

  - 给一个变量起一个别名，使得可以利用别名访问变量

  - 基本语法：`数据类型 &别名 = 原名;`
    
    Tips：
    
    - 别名的数据类型必须和原来的数据类型一致，否则不被允许

    - 引用**必须初始化**

    - 引用**不能被修改**

## 引用和函数

### 引用作函数的参数
  
  - 引用作函数的参数，可以简化指针的操作

  - 语法：`void swap(int &a, int &b){}`

    以上就是引用作为函数的参数，由于引用是直接操作和原变量同一块内存，那么此时对函数形参做的操作会直接影响到实参
    
###    引用作函数返回值

  - 函数的调用可以作为一个左值，即函数的返回值可以在调用时进行修改，其本质是返回了变量的引用

    例：
    
    ```c++
    int& test()
    {
        // static修饰的变量是静态变量，存放在全局区，不会随着函数的结束而被系统回收
        static int a = 10
        return a;
    }
    
    // 直接用函数调用修改全局变量`a`，此时`a`会被修改为20
    test() = 20;
    ```
    
    Tips：由于在函数内部定义的变量是局部变量，在运行完函数以后就会被系统回收，所以引用不适用于引用局部变量，否则会出现奇怪的错误
    
## 引用的本质

  - 引用的本质：在`c++`的底层，实际上对引用进行了封装。在我们使用引用时，实际上`c++`就为我们创建了一个**常量指针**，指向这个变量的内存空间，这也就解释了为什么引用可以传址，为什么引用不能被修改指向

## 常量引用

  - 在函数形参可以使用常量引用：`const 数据类型 & 变量名 = value;`
  - 在使用了常量引用以后，变量变为只读状态，不能被修改
    
    Tips：普通的引用不能直接指向一个**值**，如：`10`、`"string"`等等，但常量引用可以直接指向一个**值**，在`C++`底层会为这个常量先新建一个变量，再引用这个变量
    
  - 常用方法：用于修饰函数中不允许被修改的形参，防止误操作

# 函数进阶

## 函数的默认值

  在`C++`中，函数的形参是可以有默认值的
  
  - 如果我们传入了参数，则使用我们传入的参数值，如果我们没有传入参数，则使用默认值作为参数传入

  - 语法：`形参名 = 默认值`
    
    如：
    
    ```c++
    // 定义了一个函数，并给这个函数赋了初值"default"，当调用时没有给这个参数赋值时，这个参数就会以默认值传入函数
    void test(string param = "default")
    {
        std::cout << param << std::endl;
    }
    ```
    
    Tips
    - 如果一个参数有默认值，那么在它之后（右边的参数列表）的参数都必须有默认值
    - 如果在函数声明的时候给参数声明了默认值，那么在函数定义的时候就不能有默认值

## 函数占位参数

  `C++`中的形参列表中可以有占位参数，用来做占位，调用函数时必须要填补该位置
  
  - 语法：`返回值类型 函数名(数据类型){}`

  - 另外，占位参数也可以有默认参数，直接在数据类型后跟一个赋值符号即可

## 函数重载

  `c++`中支持函数重载，即支持定义函数名相同，但参数列表不同的函数定义
  
  - 作用：使得函数在不同的情境下可以有不同的用法，提高了函数的复用性
  - 函数重载的条件
    - 两个函数在同一作用域下
    - 函数名称相同
    - 参数列表不同（参数类型、参数个数、参数顺序）
      
      Tips：函数的返回值不可以作为函数重载的条件
      
### 函数重载的注意事项

  - 引用作为函数重载条件
    
    参数在传引用时，有无`const`修饰也可以作为重载的条件，但是在实际调用时，当传入一个变量的时候，则调用无`const`修饰的函数；当传入一个常量时，则调用有`const`修饰的函数
    
  - 函数重载碰到默认参数

    这种情况容易出现二义性，如：
    
    ```c++
    // 下面两个函数虽然符合函数重载的条件，但在实际调用如果只传入一个参数，则会出现二义性
    void test(int a, int b = 10){}
    void test(int a){}
    
    // 二义性
    test(10)
    ```
    
    所以，我们使用函数重载时，应避免使用默认参数
    
# 类和对象
  
  - `c++`是一门支持**面向对象**的语言

  - 面向对象认为**万物皆是对象**，对象具有以下属性和行为

    如：
    - 人可以作为对象，属性有姓名、年龄、身高……，行为有走路、跑步……
    - 车也可以作为对象，属性有轮胎、方向盘……，行为有载人、行驶……
      
      ……
        
      上述这些具有一类相同属性和行为的对象，可以被**抽象为类**
      
      如：人属于人类，车属于车类
      
  - 面向对象的三大特性
    - 封装
    - 继承
    - 多态

## 面向对象的三大特性——封装性
  - 封装的意义
    - 将属性和行为作为一个整体，表现生活中的事物
    - 将属性和行为加以权限控制
  - 在设计类的时候，属性和行为写在一起，表现事物
  - 语法：`class 类名{ 访问权限: 属性/行为};`（不同于`Java`和`C#`，`C++`的类最后要以分号结尾`;`）
    
    如：
    
    ```c++
    class Circle
    {
        // 访问权限
    public:
        // 属性
        int radius;
        
        const double PI = 3.14;
        
        // 行为
        double calculateTheZC()
        {
            return radius * 2 * PI
        }
    };
    ```
    
  - 创建（实例化）一个对象

    语法：`类名 对象名`
    
  - 访问对象的属性或行为：用`.`访问操作符

    语法：`对象名.属性/行为`
    
  - 访问权限
    - 公共权限`(public)`：类内类外均可以访问
    - 保护权限`(protected)`：类内可以访问，类外不可以访问*（子类可以访问）*
    - 私有权限`(private)`：类内可以访问，类外不可以访问*（子类不可以访问）*

  - 成员属性设置为私有的优点
    - 成员属性设置为私有，可以自己控制读写的权限
    - 对于写权限，我们可以检测数据的有效性

## 成员的初始化和清理

  - 

## struct和class的区别

  在`C++`中，`struct`和`class`唯一的区别就在于**默认的访问权限不同**
  
  区别：
  - `struct`的默认访问权限为`public`
  - `class`默认的访问权限为`private`

