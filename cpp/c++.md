[TOC]

# c++的第一个程序

```c++
#include <iostream>
using namespace std;

int main() 
{
	cout << "hello world" << endl;

	system("pause");
	return 0;
}
```

# 变量

## 创建变量的语法

* 数据类型 变量名 = 变量初始化值；	例：`int a = 0;`

```c++
#include <iostream>
using namespace std;

int main()
{
	int a = 10;
	cout << "a = " << a << endl;

	return 0;
}
```

# 常量

## 宏常量

* #define 常量名 常量值;	例：`#define DAY 7`

## `const`修饰的变量

* `const` 变量类型 变量名 = 变量值；	例：`const int MONTH = 12;`

```c++
#include <iostream>
using namespace std;

// 定义一个宏常量
#define DAY 7

int main()
{
	// 定义一个const修饰的变量
	const int MONTH = 12;
	cout << "一周有：" << DAY << "天" << endl;
	cout << "一年有：" << MONTH << "月" << endl;
	return 0;
}
```

# 标识符

* 标识符不得与关键字相同
* 标识符只能由字母、下划线"`_`"、数字组成
* 第一个字符必须是字母或下划线
* 区分大小写

<font style="color:gray">Tips：在取名时，要尽量做到见名知意，避免`a = 123;`这种让人不能一下子知道它是什么的变量名</font>

# 数据类型

## sizeof关键字

* 作用：统计变量/变量类型所占的内存空间的大小
* 语法：`sizeof(变量名/变量类型)`

<font style="color:gray">Tips具体例子在具体使用时会体现</font>

## 整型

| 数据类型  |                          占用空间                          |
| :-------: | :--------------------------------------------------------: |
|   short   |                           2 byte                           |
|    int    |                           4 byte                           |
|   long    | windows下为4 byte，Linux中为4 byte（32位）或8 byte（64位） |
| long long |                           8 byte                           |

* 以下为测试c++中各整型的长度（利用`sizeof`关键字）

```c++
#include <iostream>
using namespace std;

int main()
{
	// 短整型
	short a = 0;
	// 整型
	int b = 0;
	// 长整型
	long c = 0;
	// 长长整型
	long d = 0;

	cout << "short 类型的长度为：" << sizeof(a) << endl;
	cout << "int 类型的长度为：" << sizeof(b) << endl;
	cout << "long 类型的长度为：" << sizeof(c) << endl;
	cout << "long long 类型的长度为：" << sizeof(d) << endl;

	return 0;
}
```



![整型的数据长度](整型的数据长度.png)

## 浮点型（实型）

* 浮点型可以用于表示小数

| 数据类型 | 占用空间 | 有效数字范围 |
| :------: | :------: | :----------: |
|  float   |  4 byte  |     7位      |
|  double  |  8 byte  |   15~16位    |

* 以下为c++中各浮点型的使用以及所占内存空间的测试

``` c++
#include <iostream>
using namespace std;

int main()
{
	// 单精度浮点型
	float a = 123.12;
	// 双精度浮点型
	double b = 12.234;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "float 所占的内存空间大小为：" << sizeof(float) << endl;
	cout << "double 所占的内存空间大小为：" << sizeof(double) << endl;

	return 0;
}
```

![浮点型的使用和所占的内存空间大小](浮点型的使用和所占的内存空间大小.png)

-----

后面部分跳过

-----

# 指针

- 指针是一个存放了地址的变量，我们可以通过指针间接访问内存

- 定义一个指针

  `数据类型 * 变量名 = &另一个变量a`（`&`为取址符号，用于获取变量`a`的地址）

- 解引用

  解引用的意思是解开指针对地址的引用，这里解开指取得该地址的值，格式如下

  `*变量名 = 值`

  例：

    ```c++
    // 定义一个指针并将a的地址赋值给它
    int a = 1243;
    int * p = &a;
    // 对指针进行解引用
    *p = 1234;
    cout << "*p = " << *p << endl
    ```

- 指针对内存的占用

  - 32位操作系统下，指针占用4个字节
  - 64位操作系统下，指针占用8个字节

### 空指针、野指针

- 空指针：指向内存中内存编号为0的空间的指针

  作用：初始化指针变量

  Tips：编号`0~255`的指针都是不允许访问的

- 野指针：指向内存中非法内存空间的指针

  一般来说，我们新建或者说定义一个变量的过程，就是向系统申请内存空间的过程，未经系统允许，我们是不允许随意操作系统中的内存的。所以如果我们将一个指针指向了一个未经允许的地址，那么这个指针就会被判定为野指针，并且系统会报错，不允许我们对该地址进行操作

## 常量和指针

`const`修饰指针的三种情况

- `const`修饰指针：常量指针

  **指针的指向可变，指向的值不可变**

  `const 数据类型 * 变量名 = &a;`

- `const`修饰常量：指针常量

  **指针的指向不可边，指向的值可变**

  `数据类型 * const 变量名 = &a;`

- `const`既修饰指针，又修饰常量

  **指针的指向和值都不可变**

  `const 数据类型 * const 变量名 = &a;`

## 指针和数组

- 数组：数组是一段连续的空间中存放的相同类型的数据元素

  数组名代表的就是数组的第一个元素的地址

  - 因此，我们只需要先将指针指向数组首地址：`int * p = arr;`

  - 然后每一次读取完元素以后让指针往后偏移**一个单位长度（如int类型往后偏移4个字节）**：`p ++;`

  - 然后再进行读取：`*p;`

    *那么依照以上步骤进行下去，指针就能把整个数组遍历完*

## 指针和函数

- 传值

  ```c++
  void swap(int a, int b)
  {
      a = a + b;
      b = a - b;
      a = a - b;
      cout << a << b << endl;
  }
  ```

  以上`swap`函数只是将传入的形参做了一个拷贝，交换的并不是真正的变量，而是原变量的**副本**，**这种传递方式为传值**

- 传引用

  ```c++
  void swap(int * a, int * b)
  {
      *a = *a + *b;
      *b = *a - *b;
      *a = *a - *b;
      std::cout << *a << *b << std::endl;
  }
  ```

  而以上`swap`函数则是将地址作为参数传进了函数体，操作的是我们真正想要交换的变量，**这种传递方式则为传引用**

# 结构体

结构体属于**用户自定义的数据类型**，允许用户存储不同的数据类型

## 结构体的定义和使用

- 结构体的定义

  `struct 结构体名{结构体成员};`

- 通过结构体创建变量的方式

  - `struct 结构体名 变量名;` 

  - `struct 结构体名 变量名 = {成员1, 成员2......};`

  - 在定义结构体的时候，就将变量创建好，后续可以直接调用

    ```c++
    // 定义结构体
    struct Student
    {
        // 成员列表
        string name;
        int age;
        float score;
    }stu3; // 创建结构体变量的第3种方式
    
    // 创建结构体变量的第1种方式
    struct stu1;
    // 创建结构体变量的第2种方式
    struct stu2 = {"abc", 12, 99};
    ```

    Tips：在结构体变量**创建**时，

- 访问结构体成员：`结构体名.成员名`

## 结构体数组

- 作用：将自定义的结构体存放到数组种方便维护

- 语法：

  - 创建结构体数组：`struct 结构体名 数组名[元素个数] = { { }, { }, ..., { } };`
  - 访问结构体数组：`数组名[索引].成员名`（可以对结构体数组的某一元素的成员进行赋值或调用）

  例：

  ```c++
  // 定义一个结构体
  struct Student
  {
      string name;
      int age;
      float score;
  };
  
  // 创建结构体数组
  struct Student students[3] = 
  {
      {"zhangsan", 18, 60},
      {"lisi", 19, 65},
      {"wangwu", 18, 90} 
  };
  
  // 访问结构体数组中的元素
  std::cout << students[2].name << std::endl; // "wangwu"
  ```

## 结构体指针

- 结构体指针的定义：`struct 结构体名 * 指针名 = 变量取址;`

- 结构体指针访问结构体成员：`指针名 -> 成员名`

  例：

  ```c++
  // 结构体指针的定义
  struct Student * p = &student; // student{ name = "wangwu", age = 18, score = 90 }
  
  // 访问成员
  std::cout << "姓名: " << p -> name << std::endl; // "姓名: wangwu"
  ```

  

## 结构体嵌套

- 结构体嵌套：定义一个结构体时，将另一个结构体作为该结构体的成员

  例：

  ```c++
  struct student { };
  struct teacher
  {
      // 嵌套的学生结构体
      struct student stu;
  };
  ```

## 结构体作为函数参数

- 将结构体作为参数向函数中传递

- 结构体作为函数参数传递有两种方式

  - 值传递

    直接将变量作为参数传入函数

    函数的定义：`void func1(struct student s) { }`

  - 址传递

    将变量的地址作为参数传入函数，利用一个指针来接收这个地址

    函数的定义：`void func2(struct student * s) { }`

## const的使用场景

  - 防止在结构体中的误操作

# C++的内存四区

  C++在运行时，将内存大方向划分为**4个区域**
  - 代码区：存放函数体的二进制代码，由操作系统进行管理
  - 全局区：存放全局变量和静态变量以及常量
  - 栈区：由**编译器自动分配释放**，存放函数的参数值、局部变量等
  - 堆区：由**程序员分配和释放**，若程序员不释放，程序结束时由操作系统回收

  意义：给不同区域存放的数据，赋予不同的生命周期，使我们更灵活地编程

##  程序运行前

  在程序编译后，生成了可执行程序，**未执行程序前**，分为两个区域

  - 代码区
    - 存放`CPU`执行的机器指令
    - 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
    - 代码区是**只读**的，使其只读的愿意是防止程序意外的修改了它的指令
  - 全局区
    - 全局变量和静态变量存放在这里
    - 全局区还包括了常量区，所有的常量都存放在这里
    - 该区域的数据在程序结束后**由操作系统释放**
## 程序运行后
  - 栈区
    - 由编译器**自动分配和释放**，存放函数的参数值、局部变量等
    - Tips：**不要返回局部变量的地址**，栈区开辟的数据由编译器自动释放
  - 堆区
    - 由**程序员分配释放**，若程序员不释放，程序结束时由操作系统回收
    - 在`C++`中主要使用`new`关键字开辟内存
## new关键字

  - `C++`利用`new`关键字在堆区中开辟内存
  - 在堆中开辟的内存空间需要程序员手动释放，释放内存使用`delete`关键字
  - 语法：`new 数据类型[(初始化参数列表)]`
  - Tips
    - 使用`new`创建的数据会返回一个指针，所以我们应该用一个相应类型的指针对数据进行接收
    - 利用`delete`释放以后的内存属于系统，我们没有访问权限，所以释放了内存以后不允许再通过指针访问该内存
    - 利用`new`关键字的数组类型的创建和释放需要在数据类型和`delete`关键字后跟`[]`

      ```C++
      // 创建数组，创建了一个长度为10的数组，语法：new 数据类型[数组长度]
      int * arr = new int[10];
      // 释放数组，释放了一个数组，需要加上[]来说明释放的是一个数组，否则只会释放第一个元素
      delete[] arr;
      ```
    
# 引用

  - 给一个变量起一个别名，使得可以利用别名访问变量

  - 基本语法：`数据类型 &别名 = 原名;`
    
    Tips：
    
    - 别名的数据类型必须和原来的数据类型一致，否则不被允许

    - 引用**必须初始化**

    - 引用**不能被修改**

## 引用和函数

### 引用作函数的参数

  - 引用作函数的参数，可以简化指针的操作

  - 语法：`void swap(int &a, int &b){}`

    以上就是引用作为函数的参数，由于引用是直接操作和原变量同一块内存，那么此时对函数形参做的操作会直接影响到实参
    
###    引用作函数返回值

  - 函数的调用可以作为一个左值，即函数的返回值可以在调用时进行修改，其本质是返回了变量的引用

    例：
    
    ```c++
    int& test()
    {
        // static修饰的变量是静态变量，存放在全局区，不会随着函数的结束而被系统回收
        static int a = 10
        return a;
    }
    
    // 直接用函数调用修改全局变量`a`，此时`a`会被修改为20
    test() = 20;
    ```
    
    Tips：由于在函数内部定义的变量是局部变量，在运行完函数以后就会被系统回收，所以引用不适用于引用局部变量，否则会出现奇怪的错误
    
## 引用的本质

  - 引用的本质：在`c++`的底层，实际上对引用进行了封装。在我们使用引用时，实际上`c++`就为我们创建了一个**常量指针**，指向这个变量的内存空间，这也就解释了为什么引用可以传址，为什么引用不能被修改指向

## 常量引用

  - 在函数形参可以使用常量引用：`const 数据类型 & 变量名 = value;`
  - 在使用了常量引用以后，变量变为只读状态，不能被修改
    
    Tips：普通的引用不能直接指向一个**值**，如：`10`、`"string"`等等，但常量引用可以直接指向一个**值**，在`C++`底层会为这个常量先新建一个变量，再引用这个变量
    
  - 常用方法：用于修饰函数中不允许被修改的形参，防止误操作

# 函数进阶

## 函数的默认值

  在`C++`中，函数的形参是可以有默认值的

  - 如果我们传入了参数，则使用我们传入的参数值，如果我们没有传入参数，则使用默认值作为参数传入

  - 语法：`形参名 = 默认值`
    
    如：
    
    ```c++
    // 定义了一个函数，并给这个函数赋了初值"default"，当调用时没有给这个参数赋值时，这个参数就会以默认值传入函数
    void test(string param = "default")
    {
        std::cout << param << std::endl;
    }
    ```
    
    Tips
    - 如果一个参数有默认值，那么在它之后（右边的参数列表）的参数都必须有默认值
    - 如果在函数声明的时候给参数声明了默认值，那么在函数定义的时候就不能有默认值

## 函数占位参数

  `C++`中的形参列表中可以有占位参数，用来做占位，调用函数时必须要填补该位置

  - 语法：`返回值类型 函数名(数据类型){}`

  - 另外，占位参数也可以有默认参数，直接在数据类型后跟一个赋值符号即可

## 函数重载

  `c++`中支持函数重载，即支持定义函数名相同，但参数列表不同的函数定义

  - 作用：使得函数在不同的情境下可以有不同的用法，提高了函数的复用性
  - 函数重载的条件
    - 两个函数在同一作用域下
    - 函数名称相同
    - 参数列表不同（参数类型、参数个数、参数顺序）
      
      Tips：函数的返回值不可以作为函数重载的条件
      
### 函数重载的注意事项

  - 引用作为函数重载条件
    
    参数在传引用时，有无`const`修饰也可以作为重载的条件，但是在实际调用时，当传入一个变量的时候，则调用无`const`修饰的函数；当传入一个常量时，则调用有`const`修饰的函数
    
  - 函数重载碰到默认参数

    这种情况容易出现二义性，如：
    
    ```c++
    // 下面两个函数虽然符合函数重载的条件，但在实际调用如果只传入一个参数，则会出现二义性
    void test(int a, int b = 10){}
    void test(int a){}
    
    // 二义性
    test(10)
    ```
    
    所以，我们使用函数重载时，应避免使用默认参数
    
# 类和对象

  - `c++`是一门支持**面向对象**的语言

  - 面向对象认为**万物皆是对象**，对象具有以下属性和行为

    如：
    - 人可以作为对象，属性有姓名、年龄、身高……，行为有走路、跑步……
    - 车也可以作为对象，属性有轮胎、方向盘……，行为有载人、行驶……
      
      ……
      
      上述这些具有一类相同属性和行为的对象，可以被**抽象为类**
      
      如：人属于人类，车属于车类
    
  - 面向对象的三大特性
    - 封装
    - 继承
    - 多态

## 面向对象的三大特性——封装性
  - 封装的意义
    - 将属性和行为作为一个整体，表现生活中的事物
    - 将属性和行为加以权限控制
  - 在设计类的时候，属性和行为写在一起，表现事物
  - 语法：`class 类名{ 访问权限: 属性/行为};`（不同于`Java`和`C#`，`C++`的类最后要以分号结尾`;`）
    
    如：
    
    ```c++
    class Circle
    {
        // 访问权限
    public:
        // 属性
        int radius;
        
        const double PI = 3.14;
        
        // 行为
        double calculateTheZC()
        {
            return radius * 2 * PI
        }
    };
    ```
    
  - 创建（实例化）一个对象

    语法：`类名 对象名`
    
  - 访问对象的属性或行为：用`.`访问操作符

    语法：`对象名.属性/行为`
    
  - 访问权限
    - 公共权限`(public)`：类内类外均可以访问
    - 保护权限`(protected)`：类内可以访问，类外不可以访问*（子类可以访问）*
    - 私有权限`(private)`：类内可以访问，类外不可以访问*（子类不可以访问）*

  - 成员属性设置为私有的优点
    - 成员属性设置为私有，可以自己控制读写的权限
    - 对于写权限，我们可以检测数据的有效性

### 成员的初始化和清理

  对象的**初始化和清理**是两个非常重要的安全问题
  - 一个对象或者变量没有初始状态，对其使用后果是未知的
  - 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

  `c++`中提供的初始化和清理的函数：
  - 成员的初始化：构造函数
    - 语法：`类名(){}`
      - 构造函数没有返回值，也不写`void`
      - 函数名称和类名一致
      - 构造函数可以有参数，因此**可以发生重载**
      - 程序在实例化对象时会自动调用构造，无需手动调用，且只会调用一次
  - 成员的清理：析构函数
    - 语法：`~类名(){}`
      - 析构函数没有返回值，也不写`void`
      - 函数名和类名一致，在名称前有一个`~`
      - 析构函数不可以有参数，因此**不能发生重载**
      - 程序在对象销毁前会自动调用析构，无需手动调用，且只会调用一次

  Tips：如果我们没有提供构造和析构函数，则`c++`的编译器会提供默认空实现的构造和析构函数

###  构造函数的分类及调用
  - 两种分类
    - 按参数分类：有参构造和无参构造
    - 按类型分：普通构造和拷贝构造
      - 拷贝构造
        
        语法：`类名 {const 类名 &变量名}`
        
        Tips：在拷贝构造中的两个类名需要相同

  - 三种调用方式
    - 括号法
      
      普通构造：`类名 变量名[(参数列表)];`
      
      拷贝构造：`类名 变量（相同类型的变量）;`
      
      Tips：在调用无参构造时，不要使用`()`，因为`c++`会误认为它是一个函数的声明
      
      例如：
      
      ```c++
      // 实例化一个Person类的对象（假设可以使用小括号进行无参构造）
      Person p1();
      // 声明一个以Person类为返回值的p1函数
      Person p1();
      ```
      
      由上可见，如果无参构造带了小括号，和`c++`的函数声明一样，产生了二义性，而无法正常实例化一个对象
      
    - 显示法

      语法
      
      - 普通构造：`类名 变量名 = 类名[(参数列表)];`
      - 拷贝构造：`类名 变量名 = 类名(相同类型的变量);`
      
      如：`Person p1 = Person(10);`
      
      Tips：不要利用拷贝构造初始化匿名对象，`c++`会认为你重定义了一个相同的对象
      
    - 隐式转换法
      
      语法：
      - 普通构造：`类名 变量名 = 参数列表;`
      - 拷贝构造：`类名 变量名 = 相同类型的变量`
    
  - 拷贝构造函数的调用时机

    `C++`中拷贝构造函数的调用一般有以下三种情况：
    - 使用一个已经创建完毕的对象来初始化一个新对象
    - 以值传递的方式给函数参数传值
    - 以值的方式返回局部对象

      ```c++
      // 1.使用一个已经创建完毕的对象来初始化一个新对象
      void cpConstructor_1()
      {
        Person p1(20);
        // 调用Person类的拷贝构造函数，利用p1初始化p2
        Person p2(p1);
      }
      
      // 2.以值传递的方式给函数参数传值
      void cpConstructor_2()
      {
        Person p;
        // 以值传递给函数传值，相当于调用该函数的拷贝构造函数，创建一个新的对象，供我们在函数作用域内使用
        dowork(p)
      }
      
      void dowork_1(Person p){}
      
      // 3.以值方式返回局部对象
      Person dowork_2()
      {
        Person p;
        // 返回值实际上不是原来的对象，因为原来的对象的作用域只在这个函数之中，所以以值方式返回值时，实际上是创建了一个新的作用域更广的对象并返回给我们
        return p;
      }
      ```
    
  - 构造函数调用时机

    默认情况下，`C++`编译器至少给一个类添加以下三个函数
    - 默认构造函数（无参，空实现）
    - 默认析构函数（无参，空实现）
    - 默认拷贝构造函数，对属性值进行拷贝

    构造函数调用规则如下
    - 如果用户有定义有参构造函数，则`C++`不再提供默认无参构造，但会提供默认拷贝构造
    - 如果用户有定义拷贝构造函数，则`C++`不再提供其他构造函数

### 深浅拷贝

  - 浅拷贝：简单的赋值拷贝操作
    
    对于简单的值来说，浅拷贝不存在问题。但是对于指针来说，由于指针存放的值是地址，所以在浅拷贝时会直接将指针存放的地址拷贝过去，这就导致这时两个对象中存放的指针变量指向同一个地址，访问的是同一块内存。
    
    而在对象销毁前，我们应该在析构函数中释放对象所占用的所有内存。但是在释放了第一个对象后，此时对象中的指针变量已经进行了释放，也就是说这块内存空间我们已经没有权限去访问了，那么在释放被拷贝的对象的时候，对指针指向的内存就会进行二次释放，造成非法操作异常
    
    解决方法：深拷贝
  - 深拷贝：在堆中重新申请空间，进行拷贝操作

    ```c++
    class Person
    {
      int age;
      int * height;
      
      public:
        Person(const Person &p)
        {
          age = p.age;
          // height = p.height;  编译器默认的拷贝构造，指向同一块内存，导致释放时重复释放
          // 深拷贝，申请了一块新的内存空间存放拷贝过来的变量
          height = new int(*p.height);
        }
        
        ~Person()
        {
          // 析构函数，对堆区的数据进行释放
          if(height != NULL)
          {
            delete height;
            // 将指针设置为空指针，防止指针指向错乱
            height = NULL;
          }
        }
    }
    ```
    
### 初始化列表

  - 作用：`C++`提供了初始化列表语法，用来初始化属性
    
    初始化列表的方法省略了传统对属性的复制操作，使得构造函数可以不需要写大量的赋值代码，在大型项目，成员极多的情况下，初始化列表比传统的赋值效率高
    
  - 语法：`构造函数():属性1(值1), 属性2(值2)...{}`
    
    ```C++
    // 初始化列表，构造函数
    Person():name("tom"),age(18)
    {
      // 空实现即可
    }
    // 以上初始化方法写死了对象的属性，事实上，以下这种写法更为常见
    Person(string name, int age):name(name), age(age)
    {
      
    }
    ```
    
###   类对象作为另一个的类成员

  - `C++`中可以将类对象作为类成员，此时该成员被称为对象成员
  
    例如：
  
    ```C++
    class Phone
    {
      public:
      
        string pName;
        
        Phone(string name)
        {
          pName = name;
        }
    }
    
    class Person
    {
      public:
        string name;
        Phone phone;
        
        // 此处对Phone类型用一个string类型进行初始化，事实上是用了一个隐式转换：Phone phone = pName，相当于调用了Phone中相应的构造函数，创建了一个新的Phone对象并赋值给Person类下的phone
        Person(string name, string pName):name(name), phone(pName)
        {
          
        }
    }
    ```
    
  - 另外，有类的对象作为类成员时，构造该类的对象时会**先构造该类的对象成员再构造该类的对象**；销毁该类时会**先释放该类的对象再释放该类的对象成员**

    如上`Person`和`Phone`类，在构造时会先构造`Phone`对象再构造`Person`；而在释放内存时会先释放`Person`再释放`Phone`
    
### 静态成员

  - 静态成员就是在成员变量和成员函数加上关键字`static`，称之为静态成员

  - 静态成员分为
    - 静态成员变量
      - 所有对象共享同一份数据（**静态成员变量属于类**，每个对象访问到的该变量实际上都指向同一地址）
      
      - 在编译阶段分配内存（在全局区）
      
      - 类内声明，类外初始化
      
        ```c++
        class Person
        {
            public:
            	// 声明
            	static int m_A;
        };
        // 初始化
        int Person::m_A = 100;
        ```
      
      - 静态成员变量的访问
      
        - 直接通过对象访问属性的方式访问
        - 通过类名进行访问：`类名::静态成员变量`
      
    - 静态成员函数
      - 所有对象共享同一个函数
      - 静态成员函数只能访问静态成员变量
### 对象模型和this指针



### struct和class的区别

  在`C++`中，`struct`和`class`唯一的区别就在于**默认的访问权限不同**

  区别：
  - `struct`的默认访问权限为`public`
  - `class`默认的访问权限为`private`

