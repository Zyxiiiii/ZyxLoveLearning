[TOC]

# c++的第一个程序

```c++
#include <iostream>
using namespace std;

int main() 
{
	cout << "hello world" << endl;

	system("pause");
	return 0;
}
```

# 变量

## 创建变量的语法

* 数据类型 变量名 = 变量初始化值；	例：`int a = 0;`

```c++
#include <iostream>
using namespace std;

int main()
{
	int a = 10;
	cout << "a = " << a << endl;

	return 0;
}
```

# 常量

## 宏常量

* #define 常量名 常量值;	例：`#define DAY 7`

## const修饰的变量

* `const` 变量类型 变量名 = 变量值；	例：`const int MONTH = 12;`

```c++
#include <iostream>
using namespace std;

// 定义一个宏常量
#define DAY 7

int main()
{
	// 定义一个const修饰的变量
	const int MONTH = 12;
	cout << "一周有：" << DAY << "天" << endl;
	cout << "一年有：" << MONTH << "月" << endl;
	return 0;
}
```

# 标识符

* 标识符不得与关键字相同
* 标识符只能由字母、下划线"`_`"、数字组成
* 第一个字符必须是字母或下划线
* 区分大小写

<font style="color:gray">Tips：在取名时，要尽量做到见名知意，避免`a = 123;`这种让人不能一下子知道它是什么的变量名</font>

# 数据类型

## sizeof关键字

* 作用：统计变量/变量类型所占的内存空间的大小
* 语法：`sizeof(变量名/变量类型)`

<font style="color:gray">Tips具体例子在具体使用时会体现</font>

## 整型

| 数据类型  |                          占用空间                          |
| :-------: | :--------------------------------------------------------: |
|   short   |                           2 byte                           |
|    int    |                           4 byte                           |
|   long    | windows下为4 byte，Linux中为4 byte（32位）或8 byte（64位） |
| long long |                           8 byte                           |

* 以下为测试c++中各整型的长度（利用`sizeof`关键字）

```c++
#include <iostream>
using namespace std;

int main()
{
	// 短整型
	short a = 0;
	// 整型
	int b = 0;
	// 长整型
	long c = 0;
	// 长长整型
	long d = 0;

	cout << "short 类型的长度为：" << sizeof(a) << endl;
	cout << "int 类型的长度为：" << sizeof(b) << endl;
	cout << "long 类型的长度为：" << sizeof(c) << endl;
	cout << "long long 类型的长度为：" << sizeof(d) << endl;

	return 0;
}
```



![整型的数据长度](整型的数据长度.png)

## 浮点型（实型）

* 浮点型可以用于表示小数

| 数据类型 | 占用空间 | 有效数字范围 |
| :------: | :------: | :----------: |
|  float   |  4 byte  |     7位      |
|  double  |  8 byte  |   15~16位    |

* 以下为c++中各浮点型的使用以及所占内存空间的测试

``` c++
#include <iostream>
using namespace std;

int main()
{
	// 单精度浮点型
	float a = 123.12;
	// 双精度浮点型
	double b = 12.234;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "float 所占的内存空间大小为：" << sizeof(float) << endl;
	cout << "double 所占的内存空间大小为：" << sizeof(double) << endl;

	return 0;
}
```

![浮点型的使用和所占的内存空间大小](浮点型的使用和所占的内存空间大小.png)

-----

后面部分跳过

-----

# 指针

- 指针是一个存放了地址的变量，我们可以通过指针间接访问内存

- 定义一个指针

  `数据类型 * 变量名 = &另一个变量a`（`&`为取址符号，用于获取变量`a`的地址）

- 解引用

  解引用的意思是解开指针对地址的引用，这里解开指取得该地址的值，格式如下

  `*变量名 = 值`

  例：

    ```c++
    // 定义一个指针并将a的地址赋值给它
    int a = 1243;
    int * p = &a;
    // 对指针进行解引用
    *p = 1234;
    cout << "*p = " << *p << endl
    ```

- 指针对内存的占用

  - 32位操作系统下，指针占用4个字节
  - 64位操作系统下，指针占用8个字节

### 空指针、野指针

- 空指针：指向内存中内存编号为0的空间的指针

  作用：初始化指针变量

  Tips：编号`0~255`的指针都是不允许访问的

- 野指针：指向内存中非法内存空间的指针

  一般来说，我们新建或者说定义一个变量的过程，就是向系统申请内存空间的过程，未经系统允许，我们是不允许随意操作系统中的内存的。所以如果我们将一个指针指向了一个未经允许的地址，那么这个指针就会被判定为野指针，并且系统会报错，不允许我们对该地址进行操作

## 常量和指针

`const`修饰指针的三种情况

- `const`修饰指针：常量指针

  **指针的指向可变，指向的值不可变**

  `const 数据类型 * 变量名 = &a;`

- `const`修饰常量：指针常量

  **指针的指向不可边，指向的值可变**

  `数据类型 * const 变量名 = &a;`

- `const`既修饰指针，又修饰常量

  **指针的指向和值都不可变**

  `const 数据类型 * const 变量名 = &a;`

## 指针和数组

- 数组：数组是一段连续的空间中存放的相同类型的数据元素

  数组名代表的就是数组的第一个元素的地址

  - 因此，我们只需要先将指针指向数组首地址：`int * p = arr;`

  - 然后每一次读取完元素以后让指针往后偏移**一个单位长度（如int类型往后偏移4个字节）**：`p ++;`

  - 然后再进行读取：`*p;`

    *那么依照以上步骤进行下去，指针就能把整个数组遍历完*

## 指针和函数

- 传值

  ```c++
  void swap(int a, int b)
  {
      a = a + b;
      b = a - b;
      a = a - b;
      cout << a << b << endl;
  }
  ```

  以上`swap`函数只是将传入的形参做了一个拷贝，交换的并不是真正的变量，而是原变量的**副本**，**这种传递方式为传值**

- 传引用

  ```c++
  void swap(int * a, int * b)
  {
      *a = *a + *b;
      *b = *a - *b;
      *a = *a - *b;
      std::cout << *a << *b << std::endl;
  }
  ```

  而以上`swap`函数则是将地址作为参数传进了函数体，操作的是我们真正想要交换的变量，**这种传递方式则为传引用**

# 结构体

结构体属于**用户自定义的数据类型**，允许用户存储不同的数据类型

## 结构体的定义和使用

- 结构体的定义

  `struct 结构体名{结构体成员};`

- 通过结构体创建变量的方式

  - `struct 结构体名 变量名;` 

  - `struct 结构体名 变量名 = {成员1, 成员2......};`

  - 在定义结构体的时候，就将变量创建好，后续可以直接调用

    ```c++
    // 定义结构体
    struct Student
    {
        // 成员列表
        string name;
        int age;
        float score;
    }stu3; // 创建结构体变量的第3种方式
    
    // 创建结构体变量的第1种方式
    struct stu1;
    // 创建结构体变量的第2种方式
    struct stu2 = {"abc", 12, 99};
    ```

    Tips：在结构体变量**创建**时，

- 访问结构体成员：`结构体名.成员名`

## 结构体数组

- 作用：将自定义的结构体存放到数组种方便维护

- 语法：

  - 创建结构体数组：`struct 结构体名 数组名[元素个数] = { { }, { }, ..., { } };`
  - 访问结构体数组：`数组名[索引].成员名`（可以对结构体数组的某一元素的成员进行赋值或调用）

  例：

  ```c++
  // 定义一个结构体
  struct Student
  {
      string name;
      int age;
      float score;
  };
  
  // 创建结构体数组
  struct Student students[3] = 
  {
      {"zhangsan", 18, 60},
      {"lisi", 19, 65},
      {"wangwu", 18, 90} 
  };
  
  // 访问结构体数组中的元素
  std::cout << students[2].name << std::endl; // "wangwu"
  ```

## 结构体指针

- 结构体指针的定义：`struct 结构体名 * 指针名 = 变量取址;`

- 结构体指针访问结构体成员：`指针名 -> 成员名`

  例：

  ```c++
  // 结构体指针的定义
  struct Student * p = &student; // student{ name = "wangwu", age = 18, score = 90 }
  
  // 访问成员
  std::cout << "姓名: " << p -> name << std::endl; // "姓名: wangwu"
  ```

  

## 结构体嵌套

- 结构体嵌套：定义一个结构体时，将另一个结构体作为该结构体的成员

  例：

  ```c++
  struct student { };
  struct teacher
  {
      // 嵌套的学生结构体
      struct student stu;
  };
  ```

## 结构体作为函数参数

- 将结构体作为参数向函数中传递

- 结构体作为函数参数传递有两种方式

  - 值传递

    直接将变量作为参数传入函数

    函数的定义：`void func1(struct student s) { }`

  - 址传递

    将变量的地址作为参数传入函数，利用一个指针来接收这个地址

    函数的定义：`void func2(struct student * s) { }`

## const的使用场景

  - 防止在结构体中的误操作

# C++的内存四区

  C++在运行时，将内存大方向划分为**4个区域**
  - 代码区：存放函数体的二进制代码，由操作系统进行管理
  - 全局区：存放全局变量和静态变量以及常量
  - 栈区：由**编译器自动分配释放**，存放函数的参数值、局部变量等
  - 堆区：由**程序员分配和释放**，若程序员不释放，程序结束时由操作系统回收

  意义：给不同区域存放的数据，赋予不同的生命周期，使我们更灵活地编程

##  程序运行前

  在程序编译后，生成了可执行程序，**未执行程序前**，分为两个区域

  - 代码区
    - 存放`CPU`执行的机器指令
    - 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
    - 代码区是**只读**的，使其只读的愿意是防止程序意外的修改了它的指令
  - 全局区
    - 全局变量和静态变量存放在这里
    - 全局区还包括了常量区，所有的常量都存放在这里
    - 该区域的数据在程序结束后**由操作系统释放**
## 程序运行后
  - 栈区
    - 由编译器**自动分配和释放**，存放函数的参数值、局部变量等
    - Tips：**不要返回局部变量的地址**，栈区开辟的数据由编译器自动释放
  - 堆区
    - 由**程序员分配释放**，若程序员不释放，程序结束时由操作系统回收
    - 在`C++`中主要使用`new`关键字开辟内存
## new关键字

  - `C++`利用`new`关键字在堆区中开辟内存
  - 在堆中开辟的内存空间需要程序员手动释放，释放内存使用`delete`关键字
  - 语法：`new 数据类型[(初始化参数列表)]`
  - Tips
    - 使用`new`创建的数据会返回一个指针，所以我们应该用一个相应类型的指针对数据进行接收
    - 利用`delete`释放以后的内存属于系统，我们没有访问权限，所以释放了内存以后不允许再通过指针访问该内存
    - 利用`new`关键字的数组类型的创建和释放需要在数据类型和`delete`关键字后跟`[]`

      ```C++
      // 创建数组，创建了一个长度为10的数组，语法：new 数据类型[数组长度]
      int * arr = new int[10];
      // 释放数组，释放了一个数组，需要加上[]来说明释放的是一个数组，否则只会释放第一个元素
      delete[] arr;
      ```
    
# 引用

  - 给一个变量起一个别名，使得可以利用别名访问变量

  - 基本语法：`数据类型 &别名 = 原名;`
    
    Tips：
    
    - 别名的数据类型必须和原来的数据类型一致，否则不被允许

    - 引用**必须初始化**

    - 引用**不能被修改**

## 引用和函数

### 引用作函数的参数

  - 引用作函数的参数，可以简化指针的操作

  - 语法：`void swap(int &a, int &b){}`

    以上就是引用作为函数的参数，由于引用是直接操作和原变量同一块内存，那么此时对函数形参做的操作会直接影响到实参
    
###    引用作函数返回值

  - 函数的调用可以作为一个左值，即函数的返回值可以在调用时进行修改，其本质是返回了变量的引用

    例：
    
    ```c++
    int& test()
    {
        // static修饰的变量是静态变量，存放在全局区，不会随着函数的结束而被系统回收
        static int a = 10
        return a;
    }
    
    // 直接用函数调用修改全局变量`a`，此时`a`会被修改为20
    test() = 20;
    ```
    
    Tips：由于在函数内部定义的变量是局部变量，在运行完函数以后就会被系统回收，所以引用不适用于引用局部变量，否则会出现奇怪的错误
    
## 引用的本质

  - 引用的本质：在`c++`的底层，实际上对引用进行了封装。在我们使用引用时，实际上`c++`就为我们创建了一个**常量指针**，指向这个变量的内存空间，这也就解释了为什么引用可以传址，为什么引用不能被修改指向

## 常量引用

  - 在函数形参可以使用常量引用：`const 数据类型 & 变量名 = value;`
  - 在使用了常量引用以后，变量变为只读状态，不能被修改
    
    Tips：普通的引用不能直接指向一个**值**，如：`10`、`"string"`等等，但常量引用可以直接指向一个**值**，在`C++`底层会为这个常量先新建一个变量，再引用这个变量
    
  - 常用方法：用于修饰函数中不允许被修改的形参，防止误操作

# 函数进阶

## 函数的默认值

  在`C++`中，函数的形参是可以有默认值的

  - 如果我们传入了参数，则使用我们传入的参数值，如果我们没有传入参数，则使用默认值作为参数传入

  - 语法：`形参名 = 默认值`
    
    如：
    
    ```c++
    // 定义了一个函数，并给这个函数赋了初值"default"，当调用时没有给这个参数赋值时，这个参数就会以默认值传入函数
    void test(string param = "default")
    {
        std::cout << param << std::endl;
    }
    ```
    
    Tips
    - 如果一个参数有默认值，那么在它之后（右边的参数列表）的参数都必须有默认值
    - 如果在函数声明的时候给参数声明了默认值，那么在函数定义的时候就不能有默认值

## 函数占位参数

  `C++`中的形参列表中可以有占位参数，用来做占位，调用函数时必须要填补该位置

  - 语法：`返回值类型 函数名(数据类型){}`

  - 另外，占位参数也可以有默认参数，直接在数据类型后跟一个赋值符号即可

## 函数重载

  `c++`中支持函数重载，即支持定义函数名相同，但参数列表不同的函数定义

  - 作用：使得函数在不同的情境下可以有不同的用法，提高了函数的复用性
  - 函数重载的条件
    - 两个函数在同一作用域下
    - 函数名称相同
    - 参数列表不同（参数类型、参数个数、参数顺序）
      
      Tips：函数的返回值不可以作为函数重载的条件
      
### 函数重载的注意事项

  - 引用作为函数重载条件
    
    参数在传引用时，有无`const`修饰也可以作为重载的条件，但是在实际调用时，当传入一个变量的时候，则调用无`const`修饰的函数；当传入一个常量时，则调用有`const`修饰的函数
    
  - 函数重载碰到默认参数

    这种情况容易出现二义性，如：
    
    ```c++
    // 下面两个函数虽然符合函数重载的条件，但在实际调用如果只传入一个参数，则会出现二义性
    void test(int a, int b = 10){}
    void test(int a){}
    
    // 二义性
    test(10)
    ```
    
    所以，我们使用函数重载时，应避免使用默认参数
    
# 类和对象

  - `c++`是一门支持**面向对象**的语言

  - 面向对象认为**万物皆是对象**，对象具有以下属性和行为

    如：
    - 人可以作为对象，属性有姓名、年龄、身高……，行为有走路、跑步……
    - 车也可以作为对象，属性有轮胎、方向盘……，行为有载人、行驶……
      
      ……
      
      上述这些具有一类相同属性和行为的对象，可以被**抽象为类**
      
      如：人属于人类，车属于车类
    
  - 面向对象的三大特性
    - 封装
    - 继承
    - 多态

## 面向对象的三大特性——封装性
  - 封装的意义
    - 将属性和行为作为一个整体，表现生活中的事物
    - 将属性和行为加以权限控制
  - 在设计类的时候，属性和行为写在一起，表现事物
  - 语法：`class 类名{ 访问权限: 属性/行为};`（不同于`Java`和`C#`，`C++`的类最后要以分号结尾`;`）
    
    如：
    
    ```c++
    class Circle
    {
        // 访问权限
    public:
        // 属性
        int radius;
        
        const double PI = 3.14;
        
        // 行为
        double calculateTheZC()
        {
            return radius * 2 * PI
        }
    };
    ```
    
  - 创建（实例化）一个对象

    语法：`类名 对象名`
    
  - 访问对象的属性或行为：用`.`访问操作符

    语法：`对象名.属性/行为`
    
  - 访问权限
    - 公共权限`(public)`：类内类外均可以访问
    - 保护权限`(protected)`：类内可以访问，类外不可以访问*（子类可以访问）*
    - 私有权限`(private)`：类内可以访问，类外不可以访问*（子类不可以访问）*

  - 成员属性设置为私有的优点
    - 成员属性设置为私有，可以自己控制读写的权限
    - 对于写权限，我们可以检测数据的有效性

### 成员的初始化和清理

  对象的**初始化和清理**是两个非常重要的安全问题
  - 一个对象或者变量没有初始状态，对其使用后果是未知的
  - 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

  `c++`中提供的初始化和清理的函数：
  - 成员的初始化：构造函数
    - 语法：`类名(){}`
      - 构造函数没有返回值，也不写`void`
      - 函数名称和类名一致
      - 构造函数可以有参数，因此**可以发生重载**
      - 程序在实例化对象时会自动调用构造，无需手动调用，且只会调用一次
  - 成员的清理：析构函数
    - 语法：`~类名(){}`
      - 析构函数没有返回值，也不写`void`
      - 函数名和类名一致，在名称前有一个`~`
      - 析构函数不可以有参数，因此**不能发生重载**
      - 程序在对象销毁前会自动调用析构，无需手动调用，且只会调用一次

  Tips：如果我们没有提供构造和析构函数，则`c++`的编译器会提供默认空实现的构造和析构函数

###  构造函数的分类及调用
  - 两种分类
    - 按参数分类：有参构造和无参构造
    - 按类型分：普通构造和拷贝构造
      - 拷贝构造
        
        语法：`类名 {const 类名 &变量名}`
        
        Tips：在拷贝构造中的两个类名需要相同

  - 三种调用方式
    - 括号法
      
      普通构造：`类名 变量名[(参数列表)];`
      
      拷贝构造：`类名 变量（相同类型的变量）;`
      
      Tips：在调用无参构造时，不要使用`()`，因为`c++`会误认为它是一个函数的声明
      
      例如：
      
      ```c++
      // 实例化一个Person类的对象（假设可以使用小括号进行无参构造）
      Person p1();
      // 声明一个以Person类为返回值的p1函数
      Person p1();
      ```
      
      由上可见，如果无参构造带了小括号，和`c++`的函数声明一样，产生了二义性，而无法正常实例化一个对象
      
    - 显示法

      语法
      
      - 普通构造：`类名 变量名 = 类名[(参数列表)];`
      - 拷贝构造：`类名 变量名 = 类名(相同类型的变量);`
      
      如：`Person p1 = Person(10);`
      
      Tips：不要利用拷贝构造初始化匿名对象，`c++`会认为你重定义了一个相同的对象
      
    - 隐式转换法
      
      语法：
      - 普通构造：`类名 变量名 = 参数列表;`
      - 拷贝构造：`类名 变量名 = 相同类型的变量`
    
  - 拷贝构造函数的调用时机

    `C++`中拷贝构造函数的调用一般有以下三种情况：
    - 使用一个已经创建完毕的对象来初始化一个新对象
    - 以值传递的方式给函数参数传值
    - 以值的方式返回局部对象

      ```c++
      // 1.使用一个已经创建完毕的对象来初始化一个新对象
      void cpConstructor_1()
      {
        Person p1(20);
        // 调用Person类的拷贝构造函数，利用p1初始化p2
        Person p2(p1);
      }
      
      // 2.以值传递的方式给函数参数传值
      void cpConstructor_2()
      {
        Person p;
        // 以值传递给函数传值，相当于调用该函数的拷贝构造函数，创建一个新的对象，供我们在函数作用域内使用
        dowork(p)
      }
      
      void dowork_1(Person p){}
      
      // 3.以值方式返回局部对象
      Person dowork_2()
      {
        Person p;
        // 返回值实际上不是原来的对象，因为原来的对象的作用域只在这个函数之中，所以以值方式返回值时，实际上是创建了一个新的作用域更广的对象并返回给我们
        return p;
      }
      ```
    
  - 构造函数调用时机

    默认情况下，`C++`编译器至少给一个类添加以下三个函数
    - 默认构造函数（无参，空实现）
    - 默认析构函数（无参，空实现）
    - 默认拷贝构造函数，对属性值进行拷贝

    构造函数调用规则如下
    - 如果用户有定义有参构造函数，则`C++`不再提供默认无参构造，但会提供默认拷贝构造
    - 如果用户有定义拷贝构造函数，则`C++`不再提供其他构造函数

### 深浅拷贝

  - 浅拷贝：简单的赋值拷贝操作
    
    对于简单的值来说，浅拷贝不存在问题。但是对于指针来说，由于指针存放的值是地址，所以在浅拷贝时会直接将指针存放的地址拷贝过去，这就导致这时两个对象中存放的指针变量指向同一个地址，访问的是同一块内存。
    
    而在对象销毁前，我们应该在析构函数中释放对象所占用的所有内存。但是在释放了第一个对象后，此时对象中的指针变量已经进行了释放，也就是说这块内存空间我们已经没有权限去访问了，那么在释放被拷贝的对象的时候，对指针指向的内存就会进行二次释放，造成非法操作异常
    
    解决方法：深拷贝
  - 深拷贝：在堆中重新申请空间，进行拷贝操作

    ```c++
    class Person
    {
      int age;
      int * height;
      
      public:
        Person(const Person &p)
        {
          age = p.age;
          // height = p.height;  编译器默认的拷贝构造，指向同一块内存，导致释放时重复释放
          // 深拷贝，申请了一块新的内存空间存放拷贝过来的变量
          height = new int(*p.height);
        }
        
        ~Person()
        {
          // 析构函数，对堆区的数据进行释放
          if(height != NULL)
          {
            delete height;
            // 将指针设置为空指针，防止指针指向错乱
            height = NULL;
          }
        }
    }
    ```
    
### 初始化列表

  - 作用：`C++`提供了初始化列表语法，用来初始化属性
    
    初始化列表的方法省略了传统对属性的复制操作，使得构造函数可以不需要写大量的赋值代码，在大型项目，成员极多的情况下，初始化列表比传统的赋值效率高
    
  - 语法：`构造函数():属性1(值1), 属性2(值2)...{}`
    
    ```C++
    // 初始化列表，构造函数
    Person():name("tom"),age(18)
    {
      // 空实现即可
    }
    // 以上初始化方法写死了对象的属性，事实上，以下这种写法更为常见
    Person(string name, int age):name(name), age(age)
    {
      
    }
    ```
    
###   类对象作为另一个的类成员

  - `C++`中可以将类对象作为类成员，此时该成员被称为对象成员
  
    例如：
  
    ```C++
    class Phone
    {
      public:
      
        string pName;
        
        Phone(string name)
        {
          pName = name;
        }
    }
    
    class Person
    {
      public:
        string name;
        Phone phone;
        
        // 此处对Phone类型用一个string类型进行初始化，事实上是用了一个隐式转换：Phone phone = pName，相当于调用了Phone中相应的构造函数，创建了一个新的Phone对象并赋值给Person类下的phone
        Person(string name, string pName):name(name), phone(pName)
        {
          
        }
    }
    ```
    
  - 另外，有类的对象作为类成员时，构造该类的对象时会**先构造该类的对象成员再构造该类的对象**；销毁该类时会**先释放该类的对象再释放该类的对象成员**

    如上`Person`和`Phone`类，在构造时会先构造`Phone`对象再构造`Person`；而在释放内存时会先释放`Person`再释放`Phone`
    
### 静态成员

  - 静态成员就是在成员变量和成员函数加上关键字`static`，称之为静态成员

  - 静态成员分为
    - 静态成员变量
      - 所有对象共享同一份数据（**静态成员变量属于类**，每个对象访问到的该变量实际上都指向同一地址）
      
      - 在编译阶段分配内存（在全局区）
      
      - 类内声明，类外初始化
      
        ```c++
        class Person
        {
            public:
            	// 声明
            	static int m_A;
        };
        // 初始化
        int Person::m_A = 100;
        ```
      
      - 静态成员变量的访问
      
        - 直接通过对象访问属性的方式访问
        - 通过类名进行访问：`类名::静态成员变量`
      
    - 静态成员函数
      - 所有对象共享同一个函数
      - 静态成员函数只能访问静态成员变量
### 对象模型

- `c++`中每个空对象也会占用一个字节的内存空间，这是为了区分空对象所占内存的位置

- 静态成员不属于对象，所以静态成员所占的内存空间与类对象所占内存无关

- 非静态成员函数也不和成员变量放在一起，所以也不会影响对象所占的内存大小

  即：只有非静态成员变量和对象的存储空间有关

### this指针

- 由上述例子可知，静态成员和成员函数都只会存在一个实例，也就是说多个类对象指挥调用同一个函数，那么这一代码就需要一个指针来判别究竟是哪一个对象正在调用它，这个指针叫做`this`指针

  - `this`指针指向被调用的成员函数所属的对象

  - `this`指针是隐含每一个**非静态**成员函数内的一种指针

  - `this`指针不需要定义

- `this`指针的作用

  - 当形参和成员变量名相同时，可以使用`this`指针来区分
  
  - 当类的函数中需要返回对象本身时，可以使用`return *this`
  
    Tips：当返回的是该对象本身时，一般需要用一个引用来接收这个变量
  
    若直接返回值，则返回的不是这个对象本身，而是这个对象的一个**拷贝**
  
    ```cpp
    Person& PersonAddAge(Person p)
    {
        // 根据定义，this是指向该对象的指针，则可以利用 `->` 来指向该对象的成员 
        this->age = this->age + p.age;
        // 此外，还可以直接解引用得到该对象本身
        return *this;
    }
    ```
  
  - 为了更直观的表现究竟是成员还是参数，建议在引用成员的时候都使用`this`指针

### 空指针访问成员函数

- 在`C++`，空指针是可以调用成员函数的，但是要注意有没有用到`this`指针

  空指针可以访问成员中没有使用成员变量的函数，但是如果该函数使用了成员变量，则会报空指针异常

- 如果使用到了`this`指针，需要加以判断来保证代码的健壮性

  在使用了成员变量的函数体内部，添加一个条件，只有当`this`指针不为空时，函数才能正常执行，这样就保证了我们的函数不会出现空指针异常

  ```c++
  class Person
  {
      int age;
      
  public:
      void ShowClass()
      {
          std::cout << "im a class" << std::endl;
      }
      
      void GrowUp()
      {
          age++;
      }
  };
  
  void test1()
  {
      // 创建一个空的Person对象，并调用它的方法
      Person p = NULL;
      
      // 该方法体内部没有调用该对象相关的属性，所以没有调用该对象本身的this指针，函数可以正常执行
      p.ShowClass();
      
      // 由于该对象为空，调用其本身的属性相当于调用了该对象的this指针，那么一个空对象自然不存在属性，所以会抛出空指针异常
      p.GrowUp();
  }
  
  // 为了防止由于空对象调用函数导致的空指针异常，我们可以将上述类的GrowUp函数改成以下这样
  // 类定义省略
  void GrowUp()
  {
      if(this == NULL)
      {
          return;
      }
      
      age++;
  }
  ```

  

### const关键字修饰成员函数

- 常函数

  - 使用了`const`关键字修饰的函数我们称之为常函数
  - 常函数不可以修改成员属性
  - 成员属性声明时添加了关键字`mutable`后，就可以在常函数中进行修改

      ```c++
      class Person
      {
          int m_A;
          
          mutable int m_B;
          
      public:
          void Test1() const
          {
              // 改该行代码会报错，由于该函数被const修饰，为常函数，则不能在该函数体内部修改成员变量的值
              this->m_A = 100; // 报错
              
              // 但是，如果想要让常函数可以修改成员的值，可以给成员添加一个mutable关键字，使该成员在常函数内部也是可修改的左值
              this->m_B = 100; // 不报错
          }
          
          void Test2()
          {
              // 该函数为普通函数，不报错
              this->m_A = 100;
          }
      };
      ```

  常函数的本质：

  - 常函数在函数定义后面添加一个`const`关键字修饰，其实际上相当于给该函数对应的`this`指针添加了`const`修饰，使得该`this`指针成为了一个**常量指针**，那么**它所指向的就会变成了一个常量，它指向的值不允许被修改**

- 常对象

  - 声明对象前添加`const`修饰则称该对象为常对象
  - 常对象**只能调用常函数**
  
  常对象实际上相当于在实例化的时候就给`this`指针添加了`const`限定，此时不允许修改普通成员变量的值，但是可以修改使用了`mutable`关键字修饰的成员变量
  
  ```c++
  // 还是上面那个类，略
  void Test()
  {
      const Person p;
      // 报错，表达式必须是可修改的左值
      p.m_A = 100;
      // 通过，常对象可以修改mutable关键字修饰的成员变量
      p.m_B = 100;
      
      // 通过，常对象可以调用常函数
      p.Test1();
      // 报错，常对象不能调用普通函数
      p.Test2();
  }
  ```

### 友元

- 在面向对象的语言中，**私有属性想让通过允许类外的一些函数或者类进行访问**的话，就需要用到**友元**的技术

- 目的：允许一些类和函数访问该类的私有成员

- 关键字：`friend`

  全局函数作友元：

  ```c++
  class Building
  {
      
      // 以下这行代码取消注释以后，GoodFriend函数就可以访问到m_Bedroom变量了
      // friend void GoodFriend(Building *building);
      
  public:
      Building()
      {
          // 可以让所有人访问
          m_SittingRoom = "客厅";
          // 不希望所有人访问
          m_Bedroom = "卧室";
      }
      
      string m_SittingRoom;
  private:
      string m_Bedroom;
  };
  
  void GoodFriend(Building *building)
  {
      // 公有变量，不报错
      std::cout << building->m_SittingRoom << std::endl;
      // 私有变量，直接访问会报错，需要在类内声明友元
      std::cout << building->m_Bedroom << std::endl;
  }
  ```

  类作友元：类比与函数作友元， 在相应的类内声明允许访问本类的另一个类加上`friend`关键字即可

  例：

  ```c++
  class Building
  {
      // 这行代码即可将Friend添加为Building的友元
  	friend class Friend;
  };
  
  class Friend(){};
  ```

  成员函数作友元：略，以代码为例

  ```c++
  class Building
  {
      // 这行代码即可将Friend中的Test函数添加为Building的友元
  	friend void Friend::Test;
  };
  
  class Friend()
  {
      void Test(){}
  };
  ```

### struct和class的区别

在`C++`中，`struct`和`class`唯一的区别就在于**默认的访问权限不同**

区别：
  - `struct`的默认访问权限为`public`
  - `class`默认的访问权限为`private`

# 运算符重载

- 运算符重载：对已有的运算符进行重新定义，赋予其另一种功能，以适应不同的数据类型

## 加号运算符重载

- 以成员函数的形式完成重载

  通过实现编译器给定的函数名：`operator+`，就可以完成加号运算符的重载，完成了加号运算符重载以后的类对象之间可以根据我们自定义的规则进行**加法运算**

  例如：

  ```c++
  // Person类内部
  Person operator+(Person &p)
  {
      Person temp;
      temp.m_A = this->m_A + p.m_A;
      return temp;
  }
  
  // 则在调用这个方法时，不需要使用operator+进行调用，而是可以直接使用+对他们进行加和，相当于调用了operator+这个函数
  // 调用了p1.operator+(p2)，并赋值给p3
  Person p3 = p1 + p2;
  ```

- 以全局函数的形式完成重载

  ```c++
  // 不在Person类内部
  Person operator+(Person &p1, Person &p2)
  {
      Person temp;
      temp.m_A = p1.m_A + p2.m_A;
      return temp;
  }
  ```

- 总结：

  - 内置数据类型的表达式是不可发生改变的
  - 不要滥用运算符重载

## 重载左移运算符

- 重载左移运算符可以使得我们可以输出自定义的类型

    ```c++
    // 标准输出流
    /*
    	左移运算符由于需要两个参数，并且通常情况下cout出现在自定义类型的左侧，所以一般不在类内直接重载，而是以全局函数的形式进行重载
    		return:返回ostream，使得函数支持链式调用
    		
    		param:
    			1:第一个参数即为我们输出需要的标准输出流cout，类型为ostream
    			2:第二个参数为我们需要重载的自定义类型
    			
    		Tips:由于我们需要确保cout和自定义类型对象在整个过程中仅有一个，所以我们需要对其引用(&)，而不是复制
    */
    ostream & operator<<(ostream & cout, Person & p)
    {
        cout << p.m_1 << p.m_2 << endl;
        return cout;
    }
    ```

